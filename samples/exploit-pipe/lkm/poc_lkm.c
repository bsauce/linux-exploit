#include <linux/kernel.h>
#include <linux/init.h>
#include <linux/module.h>
#include <linux/msg.h>
#include <asm/uaccess.h>
#include <linux/slab.h>
#include <linux/mm.h>
#include <linux/proc_fs.h>

// We have to use iov count bigger than UIO_FASTIOV, for allocating iovecs in heap.
#define UIO_FASTIOV       8
#define UIO_MAXIOV        1024
#define UIO_IOV_COUNT	  10

struct poc_lkm_size {
	char dummy[128];
};
struct poc_lkm_object {
	unsigned long a1[UIO_IOV_COUNT];
	unsigned long a2[UIO_IOV_COUNT];
};

// Construct Use-After-Free with combination of below commands
#define POC_LKM_IOCTL_MAGIC ('P')
#define POC_LKM_CMD_0 _IOWR(POC_LKM_IOCTL_MAGIC, 0, struct poc_lkm_size)	/* Allocate */
#define POC_LKM_CMD_1 _IOWR(POC_LKM_IOCTL_MAGIC, 1, struct poc_lkm_size)	/* Generate 2nd reference */
#define POC_LKM_CMD_2 _IOWR(POC_LKM_IOCTL_MAGIC, 2, struct poc_lkm_size)	/* Free */
#define POC_LKM_CMD_3 _IOWR(POC_LKM_IOCTL_MAGIC, 3, struct poc_lkm_size)	/* Use (Write) */
#define POC_LKM_CMD_4 _IOWR(POC_LKM_IOCTL_MAGIC, 4, struct poc_lkm_size)	/* Print poc_lkm_str */

struct poc_lkm_object *uaf_object = NULL; 
struct poc_lkm_object *uaf_object_ref = NULL;
char poc_lkm_str[64] = "HellooWorld"; // Change "HelloWorld" to "AttackWorld" via exploiting!!

int poc_lkm_allocate(unsigned long arg)
{
	int r;

	uaf_object = (struct poc_lkm_object *)kmalloc(sizeof(*uaf_object), GFP_KERNEL);
	if (!uaf_object) {
		pr_err("uaf_object allocation error\n");
		return -1;
	}

	if (copy_from_user(uaf_object, arg, sizeof(*uaf_object))) {
		pr_err("copy_from_user error\n");
		return -1;
	}

	pr_info("poc_lkm_allocate success : %lx\n", (unsigned long)uaf_object);
	return 0;
}

int poc_lkm_gen_ref(void)
{
	uaf_object_ref = uaf_object;
	pr_info("poc_lkm_gen_ref success\n");
	return 0;
}

int poc_lkm_free(void)
{
	if (!uaf_object)
		return -1;
	kfree(uaf_object);
	uaf_object = NULL;
	pr_info("poc_lkm_free success\n");
	return 0;
}

int poc_lkm_uaf_write(unsigned long arg)
{
	if (!uaf_object && !uaf_object_ref)
		return -1;

	pr_info("uaf_object_ref[%lx] : %lx, %lx\n", uaf_object_ref, *(unsigned long *)uaf_object_ref, *((unsigned long *)uaf_object_ref + 1));

	// Is it reallocated properly??
	if (*(unsigned long *)uaf_object_ref < 0xffff000000000000UL && *((unsigned long *)uaf_object_ref + 1) == 0x8UL) {
		pr_info("Yap!! overwrite now!!\n");
		if (copy_from_user(uaf_object_ref, arg, sizeof(*uaf_object_ref))) {
			pr_err("copy_from_user error\n");
			return -1;
		}
	} else {
		pr_info("poc_lkm_uaf_write fail\n");
		return -1;
	}

	pr_info("poc_lkm_uaf_write success\n");
	return 0;
}

long poc_lkm_ioctl(struct file *f, unsigned int cmd, unsigned long arg)
{
	int r;

	switch (cmd) {
	case POC_LKM_CMD_0:
		r = poc_lkm_allocate(arg);
		break;
	case POC_LKM_CMD_1:
		r = poc_lkm_gen_ref();
		break;
	case POC_LKM_CMD_2:
		r = poc_lkm_free();
		break;
	case POC_LKM_CMD_3:
		r = poc_lkm_uaf_write(arg);
		break;
	case POC_LKM_CMD_4:
		r = 0;
		pr_info("poc_lkm_str : %s\n", poc_lkm_str);
		break;
	default:
		r = -1;
		break;
	}
	
	return r;
}

struct file_operations poc_lkm_fops =
{
    .owner = THIS_MODULE,
    .unlocked_ioctl = poc_lkm_ioctl,
};

static int create_poc_lkm_fops(void)
{
    proc_create("poc_lkm", 0666, NULL, &poc_lkm_fops);
	pr_info("poc_lkm_str : %lx\n", (unsigned long)&poc_lkm_str);
    return 0;
}

static int remove_poc_lkm_fops(void)
{
    remove_proc_entry("poc_lkm", NULL);
    return 0;
}

int poc_lkm_init(void)
{
	create_poc_lkm_fops();
	return 0;
}

void poc_lkm_exit(void)
{
	remove_poc_lkm_fops();
	return;
}

module_init(poc_lkm_init);
module_exit(poc_lkm_exit);
MODULE_LICENSE("GPL");
