#include <linux/kernel.h>
#include <linux/init.h>
#include <linux/module.h>
#include <linux/msg.h>
#include <asm/uaccess.h>
#include <linux/slab.h>
#include <linux/mm.h>
#include <linux/proc_fs.h>
#include <linux/sched.h>

struct poc_lkm_size {
	char dummy[128];
};
struct poc_lkm_input_val {
	int idx;
	unsigned long val;
};

#define POC_LKM_IOCTL_MAGIC ('P')
#define POC_LKM_CMD_0 _IOWR(POC_LKM_IOCTL_MAGIC, 0, struct poc_lkm_size)
#define POC_LKM_CMD_1 _IOWR(POC_LKM_IOCTL_MAGIC, 1, struct poc_lkm_size)
#define POC_LKM_CMD_2 _IOWR(POC_LKM_IOCTL_MAGIC, 2, struct poc_lkm_size)
#define POC_LKM_CMD_3 _IOWR(POC_LKM_IOCTL_MAGIC, 3, struct poc_lkm_size)

struct poc_lkm_st {
	long *a1;
	long *a2;
	long *a3;
	long *a4;
	long *a5;
	long *a6;
	long *a7;
	long *a8;
};

/* Function for putting sensitive data (kstack address) to kstack */
int poc_lkm_put_sensitive_data(unsigned long arg, long *a1, long *a2)
{
	struct poc_lkm_st st;
	
	st.a1 = a1; st.a2 = a1; st.a3 = a1; st.a4 = a1;
	st.a5 = a2; st.a6 = a2; st.a7 = a2; st.a8 = a2;
	return 0;
}

int poc_lkm_leak_kstack(unsigned long arg, long *a1, long *a2)
{
	unsigned char uni_buf[64];

	if (copy_to_user(arg, uni_buf, 64))
		return -1;

	return 0;
}

int poc_lkm_print_kstack(void)
{
	pr_info("stack : %lx, %lx\n", (unsigned long)current_thread_info(), (unsigned long)current_thread_info() & ~0x3fff);
	return 0;
}

int poc_lkm_read_write_int(unsigned long arg)
{
	int arr[16] = {0,1,2,3,4,5,6,7,};
	struct poc_lkm_input_val ival;

	if (copy_from_user(&ival, arg, sizeof(ival))) {
		pr_err("copy_from_user error\n");
		return 0;
	}

	if (ival.val == 0) {
		return arr[ival.idx];
	}

	*(unsigned long *)(arr + ival.idx) = ival.val;
	return 0;
}

long poc_lkm_ioctl(struct file *f, unsigned int cmd, unsigned long arg)
{
	long a1 = 1, a2 = 2;
	int r;
	int idx, val;

	switch (cmd) {
	case POC_LKM_CMD_0:
		r = poc_lkm_put_sensitive_data(arg, &a1, &a2);
		break;
	case POC_LKM_CMD_1:
		r = poc_lkm_leak_kstack(arg, &a1, &a2);
		break;
	case POC_LKM_CMD_2:
		r = poc_lkm_print_kstack();
		break;
	case POC_LKM_CMD_3:
		r = poc_lkm_read_write_int(arg);
		break;
	}
	
	return r;
}

struct file_operations poc_lkm_fops =
{
    .owner = THIS_MODULE,
    .unlocked_ioctl = poc_lkm_ioctl,
};

static int create_poc_lkm_fops(void)
{
    proc_create("poc_lkm", 0666, NULL, &poc_lkm_fops);
    return 0;
}

static int remove_poc_lkm_fops(void)
{
    remove_proc_entry("poc_lkm", NULL);
    return 0;
}

int poc_lkm_init(void)
{
	create_poc_lkm_fops();
	pr_info("KERNEL_DS : %lx, USER_DS : %lx\n", KERNEL_DS, USER_DS);
	return 0;
}

void poc_lkm_exit(void)
{
	remove_poc_lkm_fops();
	return;
}

module_init(poc_lkm_init);
module_exit(poc_lkm_exit);
MODULE_LICENSE("GPL");
