# Exploit CVE-2018-3639 with Linux kernel eBPF

- as knows as. Speculative store bypass, Spectre Variant4 [1]

- It's to read privileged kernel memory from unprivileged user. (non-root user)

- It exploits CVE-2018-3639 and eBPF in Linux kernel.

- Tested on 4.4.0-128-generic #154-Ubuntu kernel. (Ubuntu 16.04), CPU - Intel(R) Core(TM) i7-6700 CPU @ 3.40GHz

- Tested on 4.4.0-133-generic #154-Ubuntu kernel. (Ubuntu 16.04), CPU - Intel(R) Core(TM) i7-6700 CPU @ 3.40GHz

- Tested environment includes mitigations against Spectre, Meltdown, and SMEP, SMAP are applied. 

- First exploit code against CVE-2018-3639 is from Google project zero team. [2]
  But, the exploit requires additional assumptions such as kernel modification, ...
  So, testing the exploit is not easy.

- I updated the exploit code aginst CVE-2018-3639 to remove additional assumptions.
  and It perfectly works on specific Ubuntu kernel.
  But, Since this exploit is based on a probabilistic way, It's semi-reliable.

- Attack strategy and usage are included in exploit code. (poc_non_root.c)

# What is the most difficult problem on this exploitation?

- See below vulnerable SSB (Speculative-store-bypass) code pattern.

  ```
  *(fp-72) = victim_addr;
  *(fp-144) = fp-72;
  *(fp-216) = 0;
  ```

  ```
  (1) ptr = *(fp-144);
  (2) *ptr = fp-216;
  (3) ptr2 = *(fp-72);
  (4) secret = *ptr2;
  ```

- The goal of attack is to execute (4) instruction to get data from victim_addr.

- (1) instruction must be performed very slow to achive this attack.
  In other words, Attacker should flush fp-144 out from cache.

- The most difficult problem on this exploitation is the fact that flushing fp-144 is unfeasible.
  Cache eviction, Cache line bouncing are not suitable for flushing kernel stack. (fp-144)

# How to solve the problem?

- I tried to see the problem in other view.

- How about trying to exploit patch for Variant 1,2,3?
  Especially patch for Variant1 is tightly related to Linux kernel eBPF.

- Patch for Variant1 have implemented by 2 methods.
  - 1) Add barrier (lfence)
  - 2) Sanitize index

- I found "Santize index" doesn't have any point to be exploitable.
  But, found "Add barrier (lfence)" have some point to be exploitable!!

- In other words, Ubuntu kernels which apply lfence patch may be vulnerable on this exploit.

# Exploit lfence

- In the case of Ubuntu kernel 4.4.0-128-generic, lfence patch has applied to eBPF subsystem.
  The patch adds lfence before all load instruction of eBPF program.

- Then, SSB code pattern with lfence is as belows.

  ```
  (1) lfence;
  (2) ptr = *(fp-144);
  (3) *ptr = fp-216;
  (4) lfence;
  (5) ptr2 = *(fp-72);
  (6) lfence;
  (7) secret = *ptr2;
  ```

- The goal of attack is to execute (5), (7) before (2), (3) via out-or-order execution.

- In according with Intel manual, lfence has some interesting features.
  - lfence-1) Instructions following a lfence may be fetched and decoded, but they will not execute until the lfence completes.
  - lfence-2) lfence doesn't wait store instruction.
  - lfence-3) Loads from weakly-ordered memory types may be performed out-of-order. (Not clear meaning of "weakly-ordered")

- Then, execute instructions step-by-step.
  - (1) lfence;  wait prior load instructions, concurrently fetch and decode (2)~(7).
  - (5) ptr2 = *(fp-72);  It can be executed before (2),(3) via out-of-order and lfence-2), lfence-3).
  - (7) secret = *ptr2;  It can be executed before (2),(3) via out-of-order and lfence-2), lfence-3).
  - (2) ptr = *(fp-144);
  - (3) *ptr = fp-216;  CPU recognize speculative execution fails, cancel executions.

- One more interesting result is,
  - If victim_addr is in kernel core region or linear region, Attack succeed.
  - Buf, If victim_addr is in Module region, Attack failed.
  - Why? Not clear yet. I'm just guessing jumping lfence is impossible on different memory region.
    - kernel stack (linear) & kernel core (linear) ==> Jumping lfence is possible.
    - kernel stack (linear) & kernel module (non-linear) ==> Jumping lfence is impossible.

# Full steps for exploitation

- Infer kernel virtual address of user_leak_area. (== kernel_leak_area)
  - If an attacker is root, get the address from /proc/self/pagemap. If not, do bruteforcing with Variant4 gadget.

- Try to leak one bit for victim_addr.
  - [user app]  1) flush :  flush user_leak_area, It has same meaning to flush kernel_leak_area.
  - [eBPF prog] 2) setup-0 :  Write 0x00 to dummy stack address for making failed-speculative-execution fall through critical-path-1.
  - [eBPF prog] 3) setup-1~3 :  Set stack with proper value for exploitation.
  - [eBPF prog] 4) critical-path-0 :  Get secret bit of victim_addr via Variant4 gadget.
  - [eBPF prog] 5) critical-path-1 :  If SSB (speculative-store-bypass) doesn't happen, this program always get 0 which is predefined by setup-0. and next, exit directly.
  - [eBPF prog] 6) critical-path-2 :  Execution-flow can be reached here only if SSB happens, and at the same time, secret bit is 1. Access kernel_leak_area via Variant4 gadget.
  - [user app]  7) reload :  reload user_leak_area. If above eBPF program reaches critical-path-2, secret bit is 1. Then, attacker can get cache-hit!!

# References

- [1] https://en.wikipedia.org/wiki/Speculative_Store_Bypass
- [2] https://www.exploit-db.com/exploits/44695/
